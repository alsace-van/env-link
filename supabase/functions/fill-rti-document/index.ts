import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { vehicleData, customerData, transformationData } = await req.json();

    if (!vehicleData || !customerData) {
      throw new Error("Vehicle data and customer data are required");
    }

    // Récupérer la clé API Gemini
    const geminiApiKey = Deno.env.get("GEMINI_API_KEY");
    if (!geminiApiKey) {
      throw new Error("GEMINI_API_KEY not configured");
    }

    // Construire le prompt pour Gemini
    const prompt = `Tu es un expert en remplissage de formulaires administratifs français pour l'homologation VASP.

Je vais te fournir :
1. Les données du véhicule (carte grise)
2. Les informations du client
3. Les travaux de transformation effectués

Tu dois générer les données formatées pour remplir le formulaire RTI 03.5.1 (Aménagement en autocaravane).

DONNÉES VÉHICULE :
${JSON.stringify(vehicleData, null, 2)}

DONNÉES CLIENT :
${JSON.stringify(customerData, null, 2)}

TRAVAUX DE TRANSFORMATION :
${transformationData ? JSON.stringify(transformationData, null, 2) : "Aucun travail spécifié - utiliser les données génériques"}

Génère un objet JSON complet pour remplir le formulaire RTI avec :

{
  "annexe1": {
    "motifReception": "Aménagement en autocaravane",
    "nomPrenom": "NOM complet du client",
    "telephone": "Téléphone",
    "adressePostale": "Adresse complète",
    "numeroImmatriculation": "Depuis carte grise",
    "marque": "Depuis carte grise",
    "type": "Depuis carte grise",
    "numeroIdentification": "VIN",
    "modificationsEffectuees": "Description détaillée des travaux"
  },
  "annexe2": {
    "ptac": "Poids Total Autorisé en Charge",
    "poidsVideAvant": "À calculer",
    "poidsVideArriere": "À calculer",
    "poidsVideTotal": "À calculer",
    "nombrePassagers": "Depuis S1",
    "longueurHorsTout": "Depuis L",
    "largeurHorsTout": "Depuis B",
    "surfaceHorsTout": "À calculer (L x B)",
    "chargeUtileMarchandises": "PTAC - PV - (75 x N)",
    "empattement": "Si disponible",
    "chargeUtileMinimale": "(10 x N) + (10 x L en m)"
  },
  "annexe3": {
    "transformateur": "Nom du transformateur ou client",
    "marque": "Depuis carte grise",
    "genre": "Depuis J",
    "type": "Depuis D2",
    "numeroIdentification": "VIN",
    "descriptifTransformations": "Liste détaillée complète",
    "conformiteNotice": true,
    "dateAttestation": "Date du jour"
  },
  "plaqueTransformation": {
    "transformateur": "Nom",
    "numeroIdentification": "VIN",
    "motifRTI": "VASP CARAVANE"
  }
}

IMPORTANT : Retourne UNIQUEMENT le JSON, sans markdown ni backticks.`;

    // Appel à Gemini
    const geminiResponse = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${geminiApiKey}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: prompt,
                },
              ],
            },
          ],
          generationConfig: {
            temperature: 0.2,
            topK: 32,
            topP: 1,
            maxOutputTokens: 4096,
          },
        }),
      }
    );

    if (!geminiResponse.ok) {
      const errorText = await geminiResponse.text();
      console.error("Gemini API error:", errorText);
      throw new Error(`Gemini API error: ${geminiResponse.statusText}`);
    }

    const geminiData = await geminiResponse.json();
    const generatedText = geminiData.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!generatedText) {
      throw new Error("No text generated by Gemini");
    }

    // Parser le JSON
    let cleanedText = generatedText.trim();
    cleanedText = cleanedText.replace(/^```json\s*/i, "").replace(/\s*```$/i, "");
    cleanedText = cleanedText.trim();

    const rtiData = JSON.parse(cleanedText);

    return new Response(
      JSON.stringify({
        success: true,
        data: rtiData,
        raw_text: generatedText,
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  } catch (error) {
    console.error("Error in fill-rti-document:", error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      {
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }
});
